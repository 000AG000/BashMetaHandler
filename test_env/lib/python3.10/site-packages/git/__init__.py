# Copyright (C) 2008, 2009 Michael Trier (mtrier@gmail.com) and contributors
#
# This module is part of GitPython and is released under the
# 3-Clause BSD License: https://opensource.org/license/bsd-3-clause/

# @PydevCodeAnalysisIgnore

__all__ = [
    "Actor",
    "AmbiguousObjectName",
    "BadName",
    "BadObject",
    "BadObjectType",
    "BaseIndexEntry",
    "Blob",
    "BlobFilter",
    "BlockingLockFile",
    "CacheError",
    "CheckoutError",
    "CommandError",
    "Commit",
    "Diff",
    "DiffConstants",
    "DiffIndex",
    "Diffable",
    "FetchInfo",
    "Git",
    "GitCmdObjectDB",
    "GitCommandError",
    "GitCommandNotFound",
    "GitConfigParser",
    "GitDB",
    "GitError",
    "HEAD",
    "Head",
    "HookExecutionError",
    "INDEX",
    "IndexEntry",
    "IndexFile",
    "IndexObject",
    "InvalidDBRoot",
    "InvalidGitRepositoryError",
    "List",  # Deprecated - import this from `typing` instead.
    "LockFile",
    "NULL_TREE",
    "NoSuchPathError",
    "ODBError",
    "Object",
    "Optional",  # Deprecated - import this from `typing` instead.
    "ParseError",
    "PathLike",
    "PushInfo",
    "RefLog",
    "RefLogEntry",
    "Reference",
    "Remote",
    "RemoteProgress",
    "RemoteReference",
    "Repo",
    "RepositoryDirtyError",
    "RootModule",
    "RootUpdateProgress",
    "Sequence",  # Deprecated - import from `typing`, or `collections.abc` in 3.9+.
    "StageType",
    "Stats",
    "Submodule",
    "SymbolicReference",
    "TYPE_CHECKING",  # Deprecated - import this from `typing` instead.
    "Tag",
    "TagObject",
    "TagReference",
    "Tree",
    "TreeModifier",
    "Tuple",  # Deprecated - import this from `typing` instead.
    "Union",  # Deprecated - import this from `typing` instead.
    "UnmergedEntriesError",
    "UnsafeOptionError",
    "UnsafeProtocolError",
    "UnsupportedOperation",
    "UpdateProgress",
    "WorkTreeRepositoryUnsupported",
    "refresh",
    "remove_password_if_present",
    "rmtree",
    "safe_decode",
    "to_hex_sha",
]

__version__ = "3.1.43"

from typing import TYPE_CHECKING
from typing import Any
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Union


if TYPE_CHECKING:
    from types import ModuleType

import warnings

from git.exc import AmbiguousObjectName
from git.exc import BadName
from git.exc import BadObject
from git.exc import BadObjectType
from git.exc import CacheError
from git.exc import CheckoutError
from git.exc import CommandError
from git.exc import GitCommandError
from git.exc import GitCommandNotFound
from git.exc import GitError
from git.exc import HookExecutionError
from git.exc import InvalidDBRoot
from git.exc import InvalidGitRepositoryError
from git.exc import NoSuchPathError
from git.exc import ODBError
from git.exc import ParseError
from git.exc import RepositoryDirtyError
from git.exc import UnmergedEntriesError
from git.exc import UnsafeOptionError
from git.exc import UnsafeProtocolError
from git.exc import UnsupportedOperation
from git.exc import WorkTreeRepositoryUnsupported
from git.types import PathLike
from gitdb.util import to_hex_sha


try:
    from git.cmd import Git  # @NoMove
    from git.compat import safe_decode  # @NoMove
    from git.config import GitConfigParser  # @NoMove
    from git.db import GitCmdObjectDB  # @NoMove
    from git.db import GitDB
    from git.diff import INDEX  # @NoMove
    from git.diff import NULL_TREE
    from git.diff import Diff
    from git.diff import Diffable
    from git.diff import DiffConstants
    from git.diff import DiffIndex
    from git.index import (
        BaseIndexEntry,  # @NoMove; NOTE: This tells type checkers what util resolves to. We delete it, and it is; really resolved by __getattr__, which warns. See below on what to use instead.
    )
    from git.index import BlobFilter
    from git.index import CheckoutError
    from git.index import IndexEntry
    from git.index import IndexFile
    from git.index import StageType
    from git.index import util
    from git.objects import Blob  # @NoMove
    from git.objects import Commit
    from git.objects import IndexObject
    from git.objects import Object
    from git.objects import RootModule
    from git.objects import RootUpdateProgress
    from git.objects import Submodule
    from git.objects import TagObject
    from git.objects import Tree
    from git.objects import TreeModifier
    from git.objects import UpdateProgress
    from git.refs import HEAD  # @NoMove
    from git.refs import Head
    from git.refs import Reference
    from git.refs import RefLog
    from git.refs import RefLogEntry
    from git.refs import RemoteReference
    from git.refs import SymbolicReference
    from git.refs import Tag
    from git.refs import TagReference
    from git.remote import FetchInfo  # @NoMove
    from git.remote import PushInfo
    from git.remote import Remote
    from git.remote import RemoteProgress
    from git.repo import Repo  # @NoMove
    from git.util import Actor  # @NoMove
    from git.util import BlockingLockFile
    from git.util import LockFile
    from git.util import Stats
    from git.util import remove_password_if_present
    from git.util import rmtree
except GitError as _exc:
    raise ImportError("{}: {}".format(_exc.__class__.__name__, _exc)) from _exc


def _warned_import(message: str, fullname: str) -> "ModuleType":
    import importlib

    warnings.warn(message, DeprecationWarning, stacklevel=3)
    return importlib.import_module(fullname)


def _getattr(name: str) -> Any:
    # TODO: If __version__ is made dynamic and lazily fetched, put that case right here.

    if name == "util":
        return _warned_import(
            "The expression `git.util` and the import `from git import util` actually "
            "reference git.index.util, and not the git.util module accessed in "
            '`from git.util import XYZ` or `sys.modules["git.util"]`. This potentially '
            "confusing behavior is currently preserved for compatibility, but may be "
            "changed in the future and should not be relied on.",
            fullname="git.index.util",
        )

    for names, prefix in (
        ({"head", "log", "reference", "symbolic", "tag"}, "git.refs"),
        ({"base", "fun", "typ"}, "git.index"),
    ):
        if name not in names:
            continue

        fullname = f"{prefix}.{name}"

        return _warned_import(
            f"{__name__}.{name} is a private alias of {fullname} and subject to "
            f"immediate removal. Use {fullname} instead.",
            fullname=fullname,
        )

    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")


if not TYPE_CHECKING:
    # NOTE: The expression `git.util` gives git.index.util and `from git import util`
    # imports git.index.util, NOT git.util. It may not be feasible to change this until
    # the next major version, to avoid breaking code inadvertently relying on it.
    #
    # - If git.index.util *is* what you want, use (or import from) that, to avoid
    #   confusion.
    #
    # - To use the "real" git.util module, write `from git.util import ...`, or if
    #   necessary access it as `sys.modules["git.util"]`.
    #
    # Note also that `import git.util` technically imports the "real" git.util... but
    # the *expression* `git.util` after doing so is still git.index.util!
    #
    # (This situation differs from that of other indirect-submodule imports that are
    # unambiguously non-public and subject to immediate removal. Here, the public
    # git.util module, though different, makes less discoverable that the expression
    # `git.util` refers to a non-public attribute of the git module.)
    #
    # This had originally come about by a wildcard import. Now that all intended imports
    # are explicit, the intuitive but potentially incompatible binding occurs due to the
    # usual rules for Python submodule bindings. So for now we replace that binding with
    # git.index.util, delete that, and let __getattr__ handle it and issue a warning.
    #
    # For the same runtime behavior, it would be enough to forgo importing util, and
    # delete util as created naturally; __getattr__ would behave the same. But type
    # checkers would not know what util refers to when accessed as an attribute of git.
    del util

    # This is "hidden" to preserve static checking for undefined/misspelled attributes.
    __getattr__ = _getattr

# { Initialize git executable path

GIT_OK = None


def refresh(path: Optional[PathLike] = None) -> None:
    """Convenience method for setting the git executable path.

    :param path:
        Optional path to the Git executable. If not absolute, it is resolved
        immediately, relative to the current directory.

    :note:
        The `path` parameter is usually omitted and cannot be used to specify a custom
        command whose location is looked up in a path search on each call. See
        :meth:`Git.refresh <git.cmd.Git.refresh>` for details on how to achieve this.

    :note:
        This calls :meth:`Git.refresh <git.cmd.Git.refresh>` and sets other global
        configuration according to the effect of doing so. As such, this function should
        usually be used instead of using :meth:`Git.refresh <git.cmd.Git.refresh>` or
        :meth:`FetchInfo.refresh <git.remote.FetchInfo.refresh>` directly.

    :note:
        This function is called automatically, with no arguments, at import time.
    """
    global GIT_OK
    GIT_OK = False

    if not Git.refresh(path=path):
        return
    if not FetchInfo.refresh():  # noqa: F405
        return  # type: ignore[unreachable]

    GIT_OK = True


try:
    refresh()
except Exception as _exc:
    raise ImportError(f"Failed to initialize: {_exc}") from _exc

# } END initialize git executable path
